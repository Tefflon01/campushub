const asyncHandler = require('express-async-handler');const User = require('../models/userModel.js');const generateToken = require('../utils/generateToken.js');const sendEmail = require('../utils/sendEmail.js');const crypto = require('crypto');const registerUser = asyncHandler(async (req, res) => {  const { name, email, password } = req.body;  const userExists = await User.findOne({ email });  if (userExists) {    res.status(400);    throw new Error('User already exists');  }  const user = await User.create({    name,    email,    password,  });  if (user) {    const verificationToken = crypto.randomBytes(20).toString('hex');    user.verificationToken = crypto      .createHash('sha256')      .update(verificationToken)      .digest('hex');    await user.save();    const verificationURL = `${req.protocol}://${req.get(      'host'    )}/api/users/verify/${verificationToken}`;    const message = `Thank you for registering for CampusHub. Please click on the following link to verify your email address: ${verificationURL}`;    try {      await sendEmail({        email: user.email,        subject: 'CampusHub Email Verification',        message,      });      res.status(201).json({        message: 'Email sent for verification',      });    } catch (error) {      console.error(error);      user.verificationToken = undefined;      await user.save();      res.status(500);      throw new Error('Email could not be sent');    }  } else {    res.status(400);    throw new Error('Invalid user data');  }});const verifyUser = asyncHandler(async (req, res) => {  const verificationToken = crypto    .createHash('sha256')    .update(req.params.token)    .digest('hex');  const user = await User.findOne({ verificationToken });  if (!user) {    res.status(400);    throw new Error('Invalid token');  }  user.isVerified = true;  user.verificationToken = undefined;  await user.save();  res.json({ message: 'Email verified successfully' });});const authUser = asyncHandler(async (req, res) => {  const { email, password } = req.body;  const user = await User.findOne({ email });  if (user && (await user.matchPassword(password))) {    if (!user.isVerified) {      res.status(400);      throw new Error('Please verify your email to log in');    }    res.json({      _id: user._id,      name: user.name,      email: user.email,      faculty: user.faculty,      graduationYear: user.graduationYear,      profilePicture: user.profilePicture,      token: generateToken(user._id),    });  } else {    res.status(401);    throw new Error('Invalid email or password');  }});const forgotPassword = asyncHandler(async (req, res) => {  const user = await User.findOne({ email: req.body.email });  if (!user) {    res.status(404);    throw new Error('There is no user with that email');  }  const resetToken = user.getResetPasswordToken();  await user.save({ validateBeforeSave: false });  const resetUrl = `${req.protocol}://${req.get(    'host'  )}/resetpassword/${resetToken}`;  const message = `You are receiving this email because you (or someone else) has requested the reset of a password. Please make a PUT request to: 

 ${resetUrl}`;  try {    await sendEmail({      email: user.email,      subject: 'Password reset token',      message,    });    res.status(200).json({ success: true, data: 'Email sent' });  } catch (err) {    console.log(err);    user.resetPasswordToken = undefined;    user.resetPasswordExpire = undefined;    await user.save({ validateBeforeSave: false });    return next(new ErrorResponse('Email could not be sent', 500));  }});const resetPassword = asyncHandler(async (req, res, next) => {  const resetPasswordToken = crypto    .createHash('sha256')    .update(req.params.resettoken)    .digest('hex');  const user = await User.findOne({    resetPasswordToken,    resetPasswordExpire: { $gt: Date.now() },  });  if (!user) {    return next(new ErrorResponse('Invalid token', 400));  }  user.password = req.body.password;  user.resetPasswordToken = undefined;  user.resetPasswordExpire = undefined;  await user.save();  res.status(200).json({    success: true,    data: 'Password updated successfully',    token: generateToken(user._id),  });});const getUserProfile = asyncHandler(async (req, res) => {  const user = await User.findById(req.user._id);  if (user) {    res.json({      _id: user._id,      name: user.name,      email: user.email,      faculty: user.faculty,      graduationYear: user.graduationYear,      profilePicture: user.profilePicture,    });  } else {    res.status(404);    throw new Error('User not found');  }});const updateUserProfile = asyncHandler(async (req, res) => {  const user = await User.findById(req.user._id);  if (user) {    user.name = req.body.name || user.name;    user.faculty = req.body.faculty || user.faculty;    user.graduationYear = req.body.graduationYear || user.graduationYear;    if (req.body.password) {      user.password = req.body.password;    }    if (req.file) {      const result = await cloudinary.uploader.upload(req.file.path);      user.profilePicture = result.secure_url;    }    const updatedUser = await user.save();    res.json({      _id: updatedUser._id,      name: updatedUser.name,      email: updatedUser.email,      faculty: updatedUser.faculty,      graduationYear: updatedUser.graduationYear,      profilePicture: updatedUser.profilePicture,      token: generateToken(updatedUser._id),    });  } else {    res.status(404);    throw new Error('User not found');  }});module.exports = {  registerUser,  authUser,  verifyUser,  forgotPassword,  resetPassword,  getUserProfile,  updateUserProfile,};